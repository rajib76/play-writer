"""
intent_agent.py

Goal
- An "Intent Agent" that takes: intent + user_prompt + slots (metadata)
- It decides what’s ambiguous / missing, and generates disambiguation questions
- Uses an OpenAI model via Google ADK + LiteLLM

Setup
1) pip install google-adk litellm
2) export OPENAI_API_KEY="...your key..."
3) python intent_agent.py

Notes
- We use Runner.run_debug() for the simplest local execution (no manual session plumbing).
- The agent expects the user message as JSON (see SAMPLE_INPUT_JSON below).
"""

from __future__ import annotations

import json
import os
from typing import Any, Dict, List, Optional

from google.adk.agents import Agent
from google.adk.models.lite_llm import LiteLlm
from google.adk.runners import InMemoryRunner


SYSTEM_INSTRUCTIONS = """
You are an Intent Disambiguation Agent.

Input:
You will receive a SINGLE JSON object as the user message with:
- "intent": string
- "user_prompt": string
- "slots": list of slot specs, each:
    {
      "name": string,
      "type": string,
      "description": string,
      "valid_values": list | null
    }

Task:
1) Read intent + user_prompt + slots.
2) Determine whether any clarification is needed before downstream execution.
3) Craft a minimal set of disambiguation questions.

Rules:
- Only ask questions when needed to resolve ambiguity, missing details, contradictions, or multiple plausible interpretations.
- Prefer slot-targeted questions.
- If slot has valid_values, propose them as options.
- If everything is sufficiently clear, return no questions.

Output (STRICT JSON ONLY, no markdown, no extra text):
{
  "needs_disambiguation": boolean,
  "questions": [
    {
      "slot": string | null,
      "question": string,
      "options": list | null,
      "reason": string
    }
  ],
  "assumptions": [
    "string..."
  ]
}

Guidance:
- "slot" can be null if the ambiguity is not tied to a specific slot.
- Keep questions short and user-friendly.
""".strip()


def _require_env(var: str) -> None:
    if not os.getenv(var):
        raise RuntimeError(
            f"Missing environment variable {var}. "
            f"Set it first (e.g., export {var}='...')."
        )


def build_intent_agent(model_name: str = "openai/gpt-4o-mini") -> Agent:
    """
    model_name examples (LiteLLM format):
      - openai/gpt-4o-mini
      - openai/gpt-4.1-mini
      - openai/gpt-4.1
    """
    # LiteLLM will pick up OPENAI_API_KEY from env.
    model = LiteLlm(model=model_name)

    return Agent(
        name="intent_disambiguator",
        description="Generates disambiguation questions from an intent, a prompt, and slot metadata.",
        model=model,
        instruction=SYSTEM_INSTRUCTIONS,
    )


def extract_final_text(events: List[Any]) -> Optional[str]:
    """
    Best-effort extraction of the final agent message from ADK events.
    ADK Event shapes can vary across versions; this tries common patterns.
    """
    # Often the final agent response is the last event with "content".
    for ev in reversed(events):
        # Common: ev.content.parts[0].text
        content = getattr(ev, "content", None)
        if content is None:
            continue

        parts = getattr(content, "parts", None)
        if parts and len(parts) > 0:
            text = getattr(parts[0], "text", None)
            if isinstance(text, str) and text.strip():
                return text.strip()

        # Sometimes content itself may have "text"
        text = getattr(content, "text", None)
        if isinstance(text, str) and text.strip():
            return text.strip()

        # Fallback: stringifying content
        try:
            s = str(content).strip()
            if s:
                return s
        except Exception:
            pass

    return None


SAMPLE_INPUT_JSON: Dict[str, Any] = {
    "intent": "book_flight",
    "user_prompt": "Book me a flight to Seattle next Friday morning and keep it cheap.",
    "slots": [
        {
            "name": "origin_airport",
            "type": "string",
            "description": "Where the traveler departs from (airport or city).",
            "valid_values": None,
        },
        {
            "name": "destination_airport",
            "type": "string",
            "description": "Where the traveler arrives (airport or city).",
            "valid_values": ["SEA", "BFI", "PAE"],
        },
        {
            "name": "date",
            "type": "date",
            "description": "Departure date in ISO format (YYYY-MM-DD).",
            "valid_values": None,
        },
        {
            "name": "time_window",
            "type": "string",
            "description": "Preferred departure time window.",
            "valid_values": ["morning", "afternoon", "evening", "anytime"],
        },
        {
            "name": "budget",
            "type": "number",
            "description": "Maximum acceptable price in USD.",
            "valid_values": None,
        },
        {
            "name": "cabin_class",
            "type": "string",
            "description": "Cabin class preference.",
            "valid_values": ["economy", "premium_economy", "business", "first"],
        },
    ],
}


def main() -> None:
    _require_env("OPENAI_API_KEY")

    # 1) Build agent
    agent = build_intent_agent(model_name="openai/gpt-4o-mini")

    # 2) Create a runner (in-memory is simplest for local execution)
    runner = InMemoryRunner(agent=agent, app_name="intent_agent_demo")

    # 3) Provide a JSON payload as the user message (string)
    user_message = json.dumps(SAMPLE_INPUT_JSON, ensure_ascii=False)

    # 4) Execute (run_debug handles session creation + convenience formatting)
    events = runner.run_debug(
        user_messages=user_message,
        quiet=True,     # set False to see ADK console output
        verbose=False,  # set True to see tool calls etc. (if you add tools later)
    )

    # 5) Print the final output
    final_text = extract_final_text(events) or ""
    print("\n=== Agent Output (raw) ===\n")
    print(final_text)

    # 6) Validate it’s JSON (optional but recommended)
    print("\n=== Parsed JSON ===\n")
    try:
        parsed = json.loads(final_text)
        print(json.dumps(parsed, indent=2, ensure_ascii=False))
    except Exception as e:
        print(f"Could not parse output as JSON: {e}")


if __name__ == "__main__":
    main()
